uniform sampler2DArray tex_0;

varying vec2 texture_coordinate;

varying vec4 diffuse;
varying vec4 global_ambient;
varying vec4 ambient;
varying vec3 light_direction;
varying vec3 half_vector;
varying float distance;

varying vec3 sphere_normal;
varying float camera_distance;

varying float texture_interpolator;

uniform float height_multiplier;
uniform float noise_density;
uniform vec3 ntangent;

// variables


// functions


void main()
{
	// data
	
	
	vec4 color = global_ambient;
	vec3 sn1, sn2, sn3, tn1, tn2, tn3;
	vec4 noise_vec;
	vec4 diffuse1;
	vec4 grass, rock, dirt;	
	vec4 grass1, rock1, dirt1;
	vec4 grass2, rock2, dirt2;
	float mult = 1.0/(1.0 + camera_distance*noise_density/100000000.0);
	
	sn1 = normalize(sphere_normal);
	sn2 = cross(sn1, ntangent);
	sn3 = cross(sn1, sn2);
		
	tn1 = gl_NormalMatrix*sn1;
	tn2 = cross(tn1, gl_NormalMatrix*ntangent);
	tn3 = cross(tn1, tn2);
	
	if (mult > 0.015)
		noise_vec = noise3D(sn1*vec3(noise_density), noise_density)*mult;
	else
		noise_vec = vec4(0.0, 0.0, 0.0, 0.0);
	
	tn2 = tn2 + (tn1*dot(sn2, noise_vec.yzw))*mult;
	tn3 = tn3 + (tn1*dot(sn3, noise_vec.yzw))*mult;
	
	vec3 normal = normalize(cross(tn2, tn3));
	float d = dot(normal, tn1);
	
	dirt1 = texture2DArray(tex_0, vec3(texture_coordinate*10.0, 1.0));
	grass1 = texture2DArray(tex_0, vec3(texture_coordinate*10.0, 2.0));
	rock1 = texture2DArray(tex_0, vec3(texture_coordinate*10.0, 3.0));
	dirt2 = texture2DArray(tex_0, vec3(texture_coordinate*5.0, 1.0));
	grass2 = texture2DArray(tex_0, vec3(texture_coordinate*5.0, 2.0));
	rock2 = texture2DArray(tex_0, vec3(texture_coordinate*5.0, 3.0));
	
	grass = grass1*texture_interpolator + grass2*(1.0 - texture_interpolator);
	rock = rock1*texture_interpolator + rock2*(1.0 - texture_interpolator);
	dirt = dirt1*texture_interpolator + dirt2*(1.0 - texture_interpolator);
		
	diffuse1 = grass*d*d*d*d*(1.0 - noise_vec.x) + dirt*(1.0 - d*d*d*d)*(1.0 - noise_vec.x)*mult + rock*noise_vec.x*mult;
	
	float n_dot_l = dot(normal, normalize(light_direction));
	float n_dot_hv;
	float attenuation;
	
	if (n_dot_l > 0.0)
	{
		//attenuation = 1.0/(gl_LightSource[0].constantAttenuation + 
		//				     gl_LightSource[0].linearAttenuation * distance + 
		//				     gl_LightSource[0].quadraticAttenuation * distance * distance);
		attenuation = 1.0;
		
		color += attenuation * (diffuse1 * n_dot_l + ambient);
		n_dot_hv = max(dot(normal, normalize(half_vector)), 0.0);
		color += attenuation * gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(n_dot_hv, gl_FrontMaterial.shininess);
	}
	
	gl_FragColor = color;
}

