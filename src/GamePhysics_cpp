/*
	GamePhysics.cpp
	Blaze Game Engine 0.01

	Created by Ned Bingham on 1/17/06.
  	Copyright 2006 Sol Union. All rights reserved.

    Blaze Game Engine 0.01 is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Blaze Game Engine 0.01 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Blaze Game Engine 0.01.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "GamePhysics.h"

int ClassifyPoint(Vector Point, CTriangle Splitter)
{
	GLfloat Distance = Point.Dot(Splitter.Normal) + Splitter.Distance;
	if (Distance > 0)
		return Front;
	else if (Distance < 0)
		return Back;
	else
		return On;
}

int ClassifyTriangle(CTriangle *Face, CTriangle Splitter)
{
	int Pos[] = {0, 0, 0};
	for (int x = 0; x < 3; x++)
		Pos[ClassifyPoint(Face->Vertices[x], Splitter)]++;
	
	if (Pos[0] > 0 && Pos[1] == 0)
		return Front;
	else if (Pos[1] > 0 && Pos[0] == 0)
		return Back;
	else if (Pos[2] == 3)
		return On;
	else if ((Pos[0] == 2 && Pos[1] == 1 && Pos[2] == 0) || (Pos[1] == 2 && Pos[0] == 1 && Pos[2] == 0) || (Pos[0] == 1 && Pos[1] == 1 && Pos[2] == 1))
		return Span;
}

void BuildBSPTree(BSPNode *Node, CTriangle *Data, Vector Min, Vector Max, int NumTris, int splitterValue)
{
	if (NumTris > MaxPolysInNode)
	{
		int split = splitterValue%3;
		CTriangle Splitter;
		Vector Mid = Min + (Max - Min)/2;
		
		int NumFront = 0, NumBack = 0;
		Vector FrontMin, FrontMax;
		Vector BackMin, BackMax;
		
		if (split == 0)
		{
			Splitter.Normal = Vector(1, 0, 0);
			Splitter.Vertices[0] = Vector(Mid.x, Max.y, Max.z);
			Splitter.Vertices[1] = Vector(Mid.x, Min.y, Max.z);
			Splitter.Vertices[2] = Vector(Mid.x, Min.y, Min.z);
			Splitter.Distance = -(Splitter.Normal.Dot(Splitter.Vertices[0]));
			FrontMin = Vector(Mid.x, Min.y, Min.z);
			FrontMax = Max;
			BackMin = Min;
			BackMax = Vector(Mid.x, Max.y, Max.z);
		}
		
		else if (split == 1)
		{
			Splitter.Normal = Vector(0, 1, 0);
			Splitter.Vertices[0] = Vector(Min.x, Mid.y, Max.z);
			Splitter.Vertices[1] = Vector(Max.x, Mid.y, Max.z);
			Splitter.Vertices[2] = Vector(Max.x, Mid.y, Min.z);
			Splitter.Distance = -(Splitter.Normal.Dot(Splitter.Vertices[0]));
			FrontMin = Vector(Min.x, Mid.y, Min.z);
			FrontMax = Max;
			BackMin = Min;
			BackMax = Vector(Max.x, Mid.y, Max.z);
		}
		
		else if (split == 2)
		{
			Splitter.Normal = Vector(0, 0, 1);
			Splitter.Vertices[0] = Vector(Min.x, Max.y, Mid.z);
			Splitter.Vertices[1] = Vector(Max.x, Max.y, Mid.z);
			Splitter.Vertices[2] = Vector(Max.x, Min.y, Mid.z);
			Splitter.Distance = -(Splitter.Normal.Dot(Splitter.Vertices[0]));
			FrontMin = Vector(Min.x, Min.y, Mid.z);
			FrontMax = Max;
			BackMin = Min;
			BackMax = Vector(Max.x, Max.y, Mid.z);
		}
		CTriangle T[3];
		int Num = 0;
		for (int x = 0; x < NumTris; x++)
		{
			switch (ClassifyTriangle(&Data[x], Splitter))
			{
				case Front:
					NumFront++;
					break;
				case Back:
					NumBack++;
					break;
				case On:
					NumFront++;
					break;
				case Span:
					SplitTriangle(Splitter, Data[x], T, &Num);
					for (int y = 0; y < Num; y++)
					{
						switch (ClassifyTriangle(&T[y], Splitter))
						{
							case Front:
								NumFront++;
								break;
							case Back:
								NumBack++;
								break;
							case On:
								NumFront++;
								break;
							case Span:
								NumBack++;
								break;
						}
					}
					break;
			}
		}
		
		CTriangle Frontl[NumFront], Backl[NumBack];
		int f = 0, b = 0;
		for (int x = 0; x < NumTris; x++)
		{
			switch (ClassifyTriangle(&Data[x], Splitter))
			{
				case Front:
					Frontl[f] = Data[x];
					f++;
					break;
				case Back:
					Backl[b] = Data[x];
					b++;
					break;
				case On:
					Frontl[f] = Data[x];
					f++;
					break;
				case Span:
					SplitTriangle(Splitter, Data[x], T, &Num);
					for (int y = 0; y < Num; y++)
					{
						switch (ClassifyTriangle(&T[y], Splitter))
						{
							case Front:
								Frontl[f] = T[y];
								f++;
								break;
							case Back:
								Backl[b] = T[y];
								b++;
								break;
							case On:
								Frontl[f] = T[y];
								f++;
								break;
							case Span:
								Backl[b] = T[y];
								b++;
								break;
						}
					}
					break;
			}
		}

		Node->Splitter = Splitter;
		if (NumFront <= MaxPolysInNode)
		{
			BSPNode *FrontNode = new BSPNode;
			Node->FrontList = FrontNode;
			Node->FrontList->leaf = true;
			Geometry *G = new Geometry;
			Node->FrontList->LeafGeometry = G;
			Node->FrontList->LeafGeometry->Num = NumFront;
			for (int x = 0; x < NumFront; x++)
				Node->FrontList->LeafGeometry->Data[x] = Frontl[x];
		}
		else
		{
			BSPNode *FrontNode = new BSPNode;
			Node->FrontList = FrontNode;
			Node->FrontList->leaf = false;
			BuildBSPTree(Node->FrontList, Frontl, FrontMin, FrontMax, NumFront, split+1);
		}
		
		if (NumBack <= MaxPolysInNode)
		{
			BSPNode *BackNode = new BSPNode;
			Node->BackList = BackNode;
			Node->BackList->leaf = true;
			Geometry *G = new Geometry;
			Node->BackList->LeafGeometry = G;
			Node->BackList->LeafGeometry->Num = NumBack;
			for (int x = 0; x < NumBack; x++)
				Node->BackList->LeafGeometry->Data[x] = Backl[x];
		}
		else
		{
			BSPNode *BackNode = new BSPNode;
			Node->BackList = BackNode;
			Node->BackList->leaf = false;
			BuildBSPTree(Node->BackList, Backl, BackMin, BackMax, NumBack, split+1);
		}
	}
	else
	{
			Node->leaf = true;
			Geometry *G = new Geometry;
			Node->LeafGeometry = G;
			Node->LeafGeometry->Num = NumTris;
			for (int x = 0; x < NumTris; x++)
				Node->LeafGeometry->Data[x] = Data[x];
	}
}

void DestroyBSPTree(BSPNode *Node, bool starter)
{
	if (!Node->leaf)
	{
		DestroyBSPTree(Node->FrontList, false);
		DestroyBSPTree(Node->BackList, false);
		if (!starter)
			free(Node);
	}
	else
	{
		free(Node->LeafGeometry);
		if (!starter)
			free(Node);
	}
}

void AddShapes(Vector *P1, int P1Num, Vector *P2, int P2Num, Vector *Output, int *NumOutput)
{
	int z = 0;
	for (int x = 0; x < P1Num; x++)
	{
		for (int y = 0; y < P2Num; y++)
		{
			Output[z] = P1[x] + P2[y];
			z++;
		}
	}
	*NumOutput = z;
	int size = 0;
	Vector v[24];
	int result = 0;
	for (int x = 0; x < 24; x++)
	{
		result = 0;
		for (int y = 0; x < size; y++)
			if (Output[x] == v[y])
				result = 1;
		if (result == 0)
		{
			v[size] = Output[x];
			size++;
		}
	}
	
	for (int x = 0; x < size; x++)
		Output[x] = v[x];
	for (int x = size; x < 24; x++)
		Output[x] = Vector(0, 0, 0);
	*NumOutput = size;
}

GLfloat getmin(Vector *points, int NumPoints, Vector axis)
{
	GLfloat min = std::numeric_limits<GLfloat>::max(); 
	
	for (int ctr = 0; ctr < NumPoints; ctr++)
    {
		GLfloat dotprod = points[ctr].Dot(axis);
		if (dotprod < min)
			min = dotprod;
    }
	return min;
}

GLfloat getmax(Vector *points, int NumPoints, Vector axis)
{
	GLfloat max = -std::numeric_limits<GLfloat>::max(); 
	
	for (int ctr = 0; ctr < NumPoints; ctr++)
    {
		GLfloat dotprod = points[ctr].Dot(axis);
		if (dotprod > max)
			max = dotprod;
    }
	return max;
}

bool isect(Vector *P1, int PNum1, Vector *P2, int PNum2, Vector axis)
{
	if (getmin(P1, PNum1, axis) > getmax(P2, PNum2, axis))
		return false;
	if (getmax(P1, PNum1, axis) < getmin(P2, PNum2, axis))
		return false;
	
	return true;     
}

bool isectboxtri(Vector BoxPoints[8], CTriangle tri)
{	
	// test the x, y, and z axes
	if (!isect(BoxPoints, 8, tri.Vertices, 3, Vector(1, 0, 0)))
		return false;
	if (!isect(BoxPoints, 8, tri.Vertices, 3, Vector(0, 1, 0)))
		return false;
	if (!isect(BoxPoints, 8, tri.Vertices, 3, Vector(0, 0, 1)))
		return false;
	
	// test the triangle normal
	Vector triedge1 = tri.Vertices[1] - tri.Vertices[0];
	Vector triedge2 = tri.Vertices[2] - tri.Vertices[1];
	if (!isect(BoxPoints, 8, tri.Vertices, 3, tri.Normal))
		return false;
	
	// test the 9 edge cross products
	Vector triedge3 = tri.Vertices[0] - tri.Vertices[2];
	
	Vector boxedge1 = Vector(1, 0, 0);
	Vector boxedge2 = Vector(0, 1, 0);
	Vector boxedge3 = Vector(0, 0, 1);
	
	if (!isect(BoxPoints, 8, tri.Vertices, 3, boxedge1.Cross(triedge1)))
		return false;
	if (!isect(BoxPoints, 8, tri.Vertices, 3, boxedge1.Cross(triedge2)))
		return false;
	if (!isect(BoxPoints, 8, tri.Vertices, 3, boxedge1.Cross(triedge3)))
		return false;
	
	if (!isect(BoxPoints, 8, tri.Vertices, 3, boxedge2.Cross(triedge1)))
		return false;
	if (!isect(BoxPoints, 8, tri.Vertices, 3, boxedge2.Cross(triedge2)))
		return false;
	if (!isect(BoxPoints, 8, tri.Vertices, 3, boxedge2.Cross(triedge3)))
		return false;
	
	if (!isect(BoxPoints, 8, tri.Vertices, 3, boxedge3.Cross(triedge1)))
		return false;
	if (!isect(BoxPoints, 8, tri.Vertices, 3, boxedge3.Cross(triedge2)))
		return false;
	if (!isect(BoxPoints, 8, tri.Vertices, 3, boxedge3.Cross(triedge3)))
		return false;
	
	return true;
	
}

bool isectboxtri2(Vector BoxPoints[8], CTriangle tri, Vector Velocity)
{
	CTriangle tri2 = tri;
	for (int x = 0; x < 3; x++)
		tri2.Vertices[x] -= Velocity;
	
	if (isectboxtri(BoxPoints, tri) || isectboxtri(BoxPoints, tri2))
		return true;
	
	Vector Mid = (BoxPoints[0] + BoxPoints[6])/2;
	
	int t1 = ClassifyPoint(Mid, tri);
	int t2 = ClassifyPoint(Mid, tri2);
	
	if ((t1 == 0 && t2 == 0) || (t1 == 1 && t2 == 1))
		return false;
	else 
	{
		Vector I, N;
		if (intersect_RayTriangle(Mid, Mid+Velocity, tri.Vertices[0], tri.Vertices[1], tri.Vertices[2], &I, &N) == 1)
			return true;
	}
	
	return false;
}

Geometry FindNode(BSPNode *Node, Vector Point)
{
	if (Node->leaf)
	{
		Geometry G;
		G.Num = Node->LeafGeometry->Num;
		for (int x = 0; x < G.Num; x++)
			G.Data[x] = Node->LeafGeometry->Data[x];
		return G;
	}
	
	else
	{
		switch (ClassifyPoint(Point, Node->Splitter))
		{
			case Front:
				return FindNode(Node->FrontList, Point);
				break;
			case Back:
				return FindNode(Node->BackList, Point);
				break;
			case On:
				return FindNode(Node->FrontList, Point);
				break;
		}
	}
}

void SplitTriangle(CTriangle SplitPlane, CTriangle DataPlane, CTriangle *SplitTris, int *NumTris)
{
	int p[3];
	int on = 0, front = 0, back = 0;
	for (int x = 0; x < 3; x++)
	{
		p[x] = ClassifyPoint(DataPlane.Vertices[x], SplitPlane);
		if (p[x] == Front)
			front++;
		else if (p[x] == Back)
			back++;
		else if (p[x] == On)
			on++;
	}
	
	int OnList[on], FrontList[front], BackList[back];
	int o = 0, f = 0, b = 0;
	for (int x = 0; x < 3; x++)
	{
		if (p[x] == Front)
		{
			FrontList[f] = x;
			f++;
		}
		
		else if (p[x] == Back)
		{
			BackList[b] = x;
			b++;
		}
		
		else if (p[x] == On)
		{
			OnList[o] = x;
			o++;
		}
	}
	
	if (on == 1)
	{
		Vector I;
		if (intersect_RayPlane(DataPlane.Vertices[FrontList[0]], DataPlane.Vertices[BackList[0]], SplitPlane, &I) != 1)
			exit(0);
		*NumTris = 2;
		SplitTris[0].Vertices[0] = DataPlane.Vertices[FrontList[0]];
		SplitTris[0].Vertices[1] = I;
		SplitTris[0].Vertices[2] = DataPlane.Vertices[OnList[0]];
		CalculateNormal(SplitTris[0].Vertices[0], SplitTris[0].Vertices[1], SplitTris[0].Vertices[2], &SplitTris[0].Normal);
		SplitTris[0].Distance = -(SplitTris[0].Normal.Dot(SplitTris[0].Vertices[0]));
		
		SplitTris[1].Vertices[0] = DataPlane.Vertices[BackList[0]];
		SplitTris[1].Vertices[1] = I;
		SplitTris[1].Vertices[2] = DataPlane.Vertices[OnList[0]];
		CalculateNormal(SplitTris[1].Vertices[0], SplitTris[1].Vertices[1], SplitTris[1].Vertices[2], &SplitTris[1].Normal);
		SplitTris[1].Distance = -(SplitTris[1].Normal.Dot(SplitTris[1].Vertices[0]));
	}
	
	else if (front == 2)
	{
		Vector I1, I2;
		if (intersect_RayPlane(DataPlane.Vertices[FrontList[0]], DataPlane.Vertices[BackList[0]], SplitPlane, &I1) != 1)
			exit(1);
		if (intersect_RayPlane(DataPlane.Vertices[FrontList[1]], DataPlane.Vertices[BackList[0]], SplitPlane, &I2) != 1)
			exit(2);
		*NumTris = 3;
		
		SplitTris[0].Vertices[0] = DataPlane.Vertices[BackList[0]];
		SplitTris[0].Vertices[1] = I1;
		SplitTris[0].Vertices[2] = I2;
		CalculateNormal(SplitTris[0].Vertices[0], SplitTris[0].Vertices[1], SplitTris[0].Vertices[2], &SplitTris[0].Normal);
		SplitTris[0].Distance = -(SplitTris[0].Normal.Dot(SplitTris[0].Vertices[0]));
		
		SplitTris[1].Vertices[0] = I1;
		SplitTris[1].Vertices[1] = I2;
		SplitTris[1].Vertices[2] = DataPlane.Vertices[FrontList[0]];
		CalculateNormal(SplitTris[1].Vertices[0], SplitTris[1].Vertices[1], SplitTris[1].Vertices[2], &SplitTris[1].Normal);
		SplitTris[1].Distance = -(SplitTris[1].Normal.Dot(SplitTris[1].Vertices[0]));
		
		SplitTris[2].Vertices[0] = I2;
		SplitTris[2].Vertices[1] = DataPlane.Vertices[FrontList[0]];
		SplitTris[2].Vertices[2] = DataPlane.Vertices[FrontList[1]];
		CalculateNormal(SplitTris[2].Vertices[0], SplitTris[2].Vertices[1], SplitTris[2].Vertices[2], &SplitTris[2].Normal);
		SplitTris[2].Distance = -(SplitTris[2].Normal.Dot(SplitTris[2].Vertices[0]));
	}
	
	else if (back == 2)
	{
		Vector I1, I2;
		if (intersect_RayPlane(DataPlane.Vertices[BackList[0]], DataPlane.Vertices[FrontList[0]], SplitPlane, &I1) != 1)
			exit(3);
		if (intersect_RayPlane(DataPlane.Vertices[BackList[1]], DataPlane.Vertices[FrontList[0]], SplitPlane, &I2) != 1)
			exit(4);
		*NumTris = 3;
		
		SplitTris[0].Vertices[0] = DataPlane.Vertices[FrontList[0]];
		SplitTris[0].Vertices[1] = I1;
		SplitTris[0].Vertices[2] = I2;
		CalculateNormal(SplitTris[0].Vertices[0], SplitTris[0].Vertices[1], SplitTris[0].Vertices[2], &SplitTris[0].Normal);
		SplitTris[0].Distance = -(SplitTris[0].Normal.Dot(SplitTris[0].Vertices[0]));
		
		SplitTris[1].Vertices[0] = I1;
		SplitTris[1].Vertices[1] = I2;
		SplitTris[1].Vertices[2] = DataPlane.Vertices[BackList[0]];
		CalculateNormal(SplitTris[1].Vertices[0], SplitTris[1].Vertices[1], SplitTris[1].Vertices[2], &SplitTris[1].Normal);
		SplitTris[1].Distance = -(SplitTris[1].Normal.Dot(SplitTris[1].Vertices[0]));
		
		SplitTris[2].Vertices[0] = I2;
		SplitTris[2].Vertices[1] = DataPlane.Vertices[BackList[0]];
		SplitTris[2].Vertices[2] = DataPlane.Vertices[BackList[1]];
		CalculateNormal(SplitTris[2].Vertices[0], SplitTris[2].Vertices[1], SplitTris[2].Vertices[2], &SplitTris[2].Normal);
		SplitTris[2].Distance = -(SplitTris[2].Normal.Dot(SplitTris[2].Vertices[0]));
	}
	
	else
		exit(5);
}	

GamePhysics::GamePhysics()
{
}

void GamePhysics::AddModel(Model *Object)
{
	if (ModelList == NULL)
	{
		ModelList = Object;
		return;
	}
		
	Model *Current = ModelList;
	while (Current->Next != NULL)
		Current = Current->Next;
	Current->Next = Object;
}

void GamePhysics::DeleteModel()
{
	DestroyBSPTree(&NodeList, true);
}
		
void GamePhysics::GetMap(MeshData *MapData)
{
	Map = MapData;
	BuildBSPTree(&NodeList, Map->CData, Map->Min, Map->Max, Map->NumFaces, 0);
}

void GamePhysics::DetectCollision()
{
	Model *Current = ModelList;
	Geometry CG, NG;
	Vector I, N;
	
	Vector Center(0, 0, 0);
	Vector Box[8];
	Vector Vol[24];
	int NumOutput;
	while (Current != NULL)
	{
		for (int x = 0; x < 8; x++)
			Center += Current->Box[x]+Current->Position;
		for (int x = 0; x < 8; x++)
			Box[x] = Current->Box[x]+Current->Position;
		Center/=8;
		CG = FindNode(&NodeList, Center);
		NG = FindNode(&NodeList, Center+Current->LinearVelocity);
		for (int x = 0; x < CG.Num; x++)
		{
			AddShapes(Box, 8, CG.Data[x].Vertices, 3, Vol, &NumOutput);
			
			/*if (result == 1)
			{
				Current->LinearVelocity = (Current->LinearVelocity-Current->LinearAccelaration).Reflect(CG.Data[x].Normal.GetNorm());
				NG = FindNode(&NodeList, Center+Current->LinearVelocity);
			}*/
		}
		
		for (int x = 0; x < NG.Num; x++)
		{
			AddShapes(Box, 8, NG.Data[x].Vertices, 3, Vol, &NumOutput);
			
			/*if (result == 1)
			{
				Current->LinearVelocity = (Current->LinearVelocity-Current->LinearAccelaration).Reflect(NG.Data[x].Normal.GetNorm());
				NG = FindNode(&NodeList, Center+Current->LinearVelocity);
			}*/
		}
		Current = Current->Next;
	}
}
